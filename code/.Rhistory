install.packages("pwr")
x<-c(1,2,3,4,8)
y<c(4,3,5,7,9)
y <-c(4,3,5,7,9)
model1 <- (lm(y~x))
model1
summary(model1)
anova(model1)
resid(model1)
cov(x,y)
var(x)
plot(y~x)
cov(x,y)
var(x)
abline(model1)
y <-c(4,3,5,7,9,10000000)
model1 <- (lm(y~x))
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
model1 <- (lm(y~x))
model1
summary(model1)
anova(model1)
resid(model1) # Extract the residuals, or differences between observed and predicted values.
cov(x, y) # Calculate the covariance between 'x' and 'y', showing how they vary together.
var(x) # Calculate the variance of 'x', which measures the spread of 'x' values.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
x <-c(1,2,3,4,8,1)
y <-c(4,3,5,7,9,10000000)
model1 <- (lm(y~x))
model1
summary(model1)
anova(model1)
resid(model1) # Extract the residuals, or differences between observed and predicted values.
cov(x, y) # Calculate the covariance between 'x' and 'y', showing how they vary together.
var(x) # Calculate the variance of 'x', which measures the spread of 'x' values.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
y <-c(4,3,5,7,9,4)
model1 <- (lm(y~x))
model1
summary(model1)
anova(model1)
resid(model1) # Extract the residuals, or differences between observed and predicted values.
cov(x, y) # Calculate the covariance between 'x' and 'y', showing how they vary together.
var(x) # Calculate the variance of 'x', which measures the spread of 'x' values.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
model1 <- lm(log(y)~log(x))
model1
summary(model1)
anova(model1)
resid(model1) # Extract the residuals, or differences between observed and predicted values.
cov(x, y) # Calculate the covariance between 'x' and 'y', showing how they vary together.
var(x) # Calculate the variance of 'x', which measures the spread of 'x' values.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
x <-c(1,2,3,4,8,1,1)
y <-c(4,3,5,7,9,4,1000000)
model1 <- lm(log(y)~log(x))
model1
summary(model1)
anova(model1)
resid(model1) # Extract the residuals, or differences between observed and predicted values.
cov(x, y) # Calculate the covariance between 'x' and 'y', showing how they vary together.
var(x) # Calculate the variance of 'x', which measures the spread of 'x' values.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
x <-c(1,2,3,4,8,1,1)
y <-c(4,3,5,7,9,4,5)
model1 <- lm(y~x)
model1
summary(model1)
anova(model1)
resid(model1) # Extract the residuals, or differences between observed and predicted values.
cov(x, y) # Calculate the covariance between 'x' and 'y', showing how they vary together.
var(x) # Calculate the variance of 'x', which measures the spread of 'x' values.
plot(y~x)
abline(model1)    # Adds the regression line from 'model1' to an existing plot of 'y' vs 'x'.
rm(list=ls())
require(WebPower)
install.package("webpower")
require(WebPower)
install.package("WebPower")
require(WebPower)
Install.Package("WebPower")
require(WebPower)
install.packages("WebPower")
require(WebPower)
require(WebPower)
?WebPower
y<-rnorm(51, mean=1, sd=1.3)
x<-seq(from=0, to=5, by=0.1)
y<-rnorm(51, mean=1, sd=1.3)
x<-seq(from=0, to=5, by=0.1)
plot(hist(y, breaks=10))
mean(y)
sd(y)
segments(x0=(mean(y)), y0=(0), x1=(mean(y)), y1=40, lty=1, col="blue")
rm(list=ls())
require(WebPower)
?webpower
?WebPower
y<-rnorm(51, mean=1, sd=1.3)
x<-seq(from=0, to=5, by=0.1)
length(x)
plot(hist(y, breaks=10))
mean(y)
sd(y)
segments(x0=(mean(y)), y0=(0), x1=(mean(y)), y1=40, lty=1, col="blue")
# and now 0.25 sd left of the mean (because females are larger)
segments(x0=(mean(y)+0.25*sd(y)), y0=(0), x1=(mean(y)+0.25*sd(y)), y1=40, lty
=1, col="red")
?wp.t
wp.t(d=0.25, power=0.8, type="two.sample", alternative="two.sided")
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample.2n
", alternative="two.sided")
res.1
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample.2n
", alternative="two.sided")
res.1
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample.2n
", alternative="two.sided")
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample
", alternative="two.sided")
#a power curve could be used?
res.1<-wp.t(n1=seq(20,300,20), n2=seq(20,300,20), d=0.25, type="two.sample", alternative="two.sided")
res.1
wp.t(d=0.25, power=0.8, type="two.sample", alternative="two.sided") #default two sided test needs to be run because not enough data
plot(res.1, xvar='n1', yvar='power')
plot(res.1, xvar='n1', yvar='power')
plot(res.1, xvar='n1', yvar='n2')
plot(res.1, xvar='n1', yvar='n2')
plot(res.1)
rm(list=ls())
x<-seq(from = -5, to = 5, by = 1)
x
## [1] 3
x[[length(x)]]
x<-seq(from = -5, to = 5, by = 1)
x
a<-2 #intercept
b<-1 #slope
y<-a+b*x
plot(x,y)
segments(0,-10,0,10, lty=3) #add axes
segments(-10,0,10,0,lty=3)
plot(x,y)
segments(0,-10,0,10, lty=3) #add axes
segments(-10,0,10,0,lty=3)
?abline
plot(x,y, col="white")
segments(0,-10,0,10, lty=3)
segments(-10,0,10,0,lty=3)
abline(a = 2, b=1)
plot(x,y, col="green")
segments(0,-10,0,10, lty=3)
segments(-10,0,10,0,lty=3)
plot(x,y, col="black")
segments(0,-10,0,10, lty=3)
segments(-10,0,10,0,lty=3)
abline(a = 2, b=1)
points(4,0, col="red", pch=19)
points(-2,6, col="green", pch=9)
points(x,y, pch=c(1,2,3,4,5,6,7,8,9,10,11))
y<-x^2
plot(x,y)
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3)
segments(0,-40,0,30, lty=3)
segments(-30,0,30,0,lty=3)
segments(-30,20,30,0,lty=3)
segments(-30,0,30,0,lty=3)
segments(-30,0,30,0,lty=3)
y<-x^2
plot(x,y)
segments(-30,0,30,0,lty=3)
segments(-30,0,30,0,lty=3)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(-30,0,30,0,lty=3)
segments(0,-30,0,30, lty=3)
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-30,0,30, lty=3)
segments(0,-5,0,30, lty=3)
segments(0,-5,0,5, lty=3)
segments(0,-5,0,3, lty=3)
segments(0,-3,0,3, lty=3)
y<-x^2
plot(x,y)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-3,0,3, lty=3)
y<-x^2
plot(x,y)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-3,0,3, lty=3)
segments(0,-30,0,30, lty=3)
y<-x^2
plot(x,y)
segments(-3,0,3,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3) #starts at point -30, 0 and ends at point 30, 0
segments(0,-30,0,30, lty=3)
#give linear function intercept of a-2
x<-seq(from = -5, to = 5, by = 0.1)
a<- -2
y<-a+x^2
plot(x,y)
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3)
plot(x,y)
a<- -2
b<-3
y<-a+b*x^2
points(x,y, pch=19, col="red")
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3)
y<-a+b*x^2 #gave the curve a higher slope
points(x,y, pch=19, col="red")
segments(0,-30,0,30, lty=3)
segments(-30,0,30,0,lty=3)
plot(x,y)
a<- -2
b1<- 10
b2<-3
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-100,0,100, lty=3)
segments(-100,0,100,0,lty=3)
plot(x,y)
a<- 1
b1<- 2
b2<-0.15
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-100,0,100, lty=3)
segments(-100,0,100,0,lty=3)
plot(x,y)
a<- 1
b1<- 2
b2<-0.15
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-100,0,100, lty=3)
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
plot(x,y)
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x+b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
plot(x,y)
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
plot(x,y)
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
plot(x, y, type="n", xlim=c(-100, 100), ylim=c(-1000, 1000), main="Plot with Adjusted Scales")
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
segments(-1000,0,1000,0,lty=3)
max_y_index <- which.max(y)  # Find the index of the maximum y value
highest_x <- x[max_y_index]  # Get the corresponding x value
highest_y <- y[max_y_index]  # Get the highest y value# Find the index of the maximum y value
points(highest_x, highest_y, col="red", pch=19)
x<-seq(from = -100, to = 100, by = 1)
plot(x, y, type="n", xlim=c(-100, 100), ylim=c(-1000, 1000), main="Plot with Adjusted Scales")
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
max_y_index <- which.max(y)  # Find the index of the maximum y value
highest_x <- x[max_y_index]  # Get the corresponding x value
highest_y <- y[max_y_index]  # Get the highest y value# Find the index of the maximum y value
points(highest_x, highest_y, col="red", pch=19)
text(highest_x, highest_y, labels=paste("Max y =", round(highest_y, 2)), pos=3)
#find highest y point in equation
x<-seq(from = -100, to = 100, by = 1)
plot(x, y, type="n", xlim=c(-100, 100), ylim=c(-1000, 1000), main="Plot with Adjusted Scales")
a<- -1
b1<- 2
b2<-0.15
y<-a+b1*x-b2*x^2
points(x,y, pch=19, col="green")
segments(0,-1000,0,1000, lty=3)
segments(-1000,0,1000,0,lty=3)
max_y_index <- which.max(y)  # Find the index of the maximum y value
highest_x <- x[max_y_index]  # Get the corresponding x value
highest_y <- y[max_y_index]  # Get the highest y value# Find the index of the maximum y value
points(highest_x, highest_y, col="red", pch=19)
text(highest_x, highest_y, labels=paste("Max y =", round(highest_y, 2)), pos=3) # pos=3 places the text above the point for better visibility
library(dplyr)
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
#Local paralellisation
#run tasks in parallel for greater speed/efficiency
n <- 10000 #number of observations
data <- data.frane(
ID = sample(1:10, n, replace = TRUE), # ID column to define 10 groups
Y = rnorm(n), #creates a vector of 10000 random values from normal standard dist (mean=0,sd=1)
x = rnorm(n)
)
data <- data.frame(
ID = sample(1:10, n, replace = TRUE), # ID column to define 10 groups
Y = rnorm(n), #creates a vector of 10000 random values from normal standard dist (mean=0,sd=1)
x = rnorm(n)
)
library(dplyr)
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
View(data_groups)
# Define a function to fit a linear model for each group
fit_model <- function(group_data) {
model <- lm(y ~ X, data = group_data)
coef_df <- as.data.frame(t(coef(model)))
coef_df$ID <- unique(group_data$ID)  # Add ID for reference
return(coef_df)
}
library(dplyr)
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
# Define a function to fit a linear model for each group
fit_model <- function(group_data) {
# Fit a linear model (lm) to the data in group_data, predicting y using X
model <- lm(y ~ X, data = group_data)
# Extract the coefficients from the model and transpose them to create a one-row data frame
coef_df <- as.data.frame(t(coef(model)))
# Add a column to the coefficients data frame with the unique ID from the group_data for reference
coef_df$ID <- unique(group_data$ID)
# Return the data frame containing the model coefficients and the ID
return(coef_df)
}
library(parallel)
num_cores <- detectCores() - 1 # Use all cores but one
results <- mclapply(data_groups, fit_model, mc.cores = num_cores) # Fit the models
final_results <- bind_rows(results) # Bind model outputs from list to table
print(final_results)
library(dplyr)
data_groups <- data %>% group_by(ID) %>% group_split() # Split the data by ID
# Define a function to fit a linear model for each group
fit_model <- function(group_data) {
# Fit a linear model (lm) to the data in group_data, predicting y using X
model <- lm(y ~ X, data = data_groups)
# Extract the coefficients from the model and transpose them to create a one-row data frame
coef_df <- as.data.frame(t(coef(model)))
# Add a column to the coefficients data frame with the unique ID from the group_data for reference
coef_df$ID <- unique(group_data$ID)
# Return the data frame containing the model coefficients and the ID
return(coef_df)
}
library(parallel)
num_cores <- detectCores() - 1 # Use all cores but one
results <- mclapply(data_groups, fit_model, mc.cores = num_cores) # Fit the models
final_results <- bind_rows(results) # Bind model outputs from list to table
print(final_results)
library(parallel)
num_cores <- detectCores() - 1 # Use all cores but one
results <- mclapply(data_groups, fit_model, mc.cores = num_cores) # Fit the models
final_results <- bind_rows(results) # Bind model outputs from list to table
print(final_results)
# Define a function to fit a linear model for each group
fit_model <- function(group_data) {
# Fit a linear model (lm) to the data in group_data, predicting Y using x
model <- lm(Y ~ x, data = group_data)
# Extract the coefficients from the model and transpose them to create a one-row data frame
coef_df <- as.data.frame(t(coef(model)))
# Add a column to the coefficients data frame with the unique ID from the group_data for reference
coef_df$ID <- unique(group_data$ID)
# Return the data frame containing the model coefficients and the ID
return(coef_df)
}
# Now, run the parallel code to fit models for each group
library(parallel)
num_cores <- detectCores() - 1  # Use all cores but one
# Use mclapply to run the fit_model function on each subset of the data
results <- mclapply(data_groups, fit_model, mc.cores = num_cores)
# Bind all the results into one data frame
final_results <- bind_rows(results)
print(final_results)
# Question 12
neutral_generation <- function(community){
# Randomly select either 'floor' or 'ceiling'
floor_or_ceiling <- sample(c(floor, ceiling), 1)
# Apply the chosen function to divide by 2
generations <- chosen_function(length(community) / 2)
for (1:generations) {
setwd("~/Documents/HPC/code")
source("~/Documents/HPC/code/Sebd_HPC_2024_main.R")
source("~/Documents/HPC/code/Sebd_HPC_2024_main.R")
source("~/Documents/HPC/code/Sebd_HPC_2024_main.R")
source("~/Documents/HPC/code/Sebd_HPC_2024_main.R")
source("~/Documents/HPC/code/Sebd_HPC_2024_main.R")
# Question 12
neutral_generation <- function(community){
# Randomly select either 'floor' or 'ceiling'
floor_or_ceiling <- sample(c(floor, ceiling), 1)
# Apply the chosen function to divide by 2
generations <- chosen_function(length(community) / 2)
for (i in 1:generations) {
neutral_step(community)
}
return(community)
}
test <- (1, 2, 3, 4, 2, 1, 3)
test <- c(1, 2, 3, 4, 2, 1, 3)
neutral_generation(test)
# Question 12
neutral_generation <- function(community){
# Randomly select either 'floor' or 'ceiling'
floor_or_ceiling <- sample(c(floor, ceiling), 1)
# Apply the chosen function to divide by 2
generations <- floor_or_ceiling(length(community) / 2)
for (i in 1:generations) {
neutral_step(community)
}
return(community)
}
test <- c(1, 2, 3, 4, 2, 1, 3)
neutral_generation(test)
# Question 12
neutral_generation <- function(community){
# Randomly select either 'floor' or 'ceiling'
floor_or_ceiling <- sample(c(floor, ceiling), 1)[[1]]
# Apply the chosen function to divide by 2
generations <- floor_or_ceiling(length(community) / 2)
for (i in 1:generations) {
neutral_step(community)
}
return(community)
}
test <- c(1, 2, 3, 4, 2, 1, 3)
neutral_generation(test)
# Question 11
neutral_step <- function(community){
random_value <- floor(runif(1, min(community), max(community) + 1))
random_index <- sample(1:length(community), 1)
if (random_value != community[random_index]) {
community[random_index] <- random_value
}
return(community)
}
# Question 12
neutral_generation <- function(community){
# Randomly select either 'floor' or 'ceiling'
floor_or_ceiling <- sample(c(floor, ceiling), 1)[[1]]
# Apply the chosen function to divide by 2
generations <- floor_or_ceiling(length(community) / 2)
for (i in 1:generations) {
neutral_step(community)
}
return(community)
}
test <- c(1, 2, 3, 4, 2, 1, 3)
neutral_generation(test)
neutral_generation(test)
neutral_generation(test)
neutral_generation(test)
neutral_generation(test)
neutral_generation(test)
# Question 12
neutral_generation <- function(community){
# Randomly select either 'floor' or 'ceiling'
floor_or_ceiling <- sample(c(floor, ceiling), 1)[[1]]
# Apply the chosen function to divide by 2
generations <- floor_or_ceiling(length(community) / 2)
for (i in 1:generations) {
community <- neutral_step(community)
}
return(community)
}
test <- c(1, 2, 3, 4, 2, 1, 3)
neutral_generation(test)
neutral_generation(test)
neutral_generation(test)
neutral_generation(test)
neutral_generation(test)
load("/home/sebastian-dohne/Documents/HPC/code/output_1.rda")
View(simulation_results)
